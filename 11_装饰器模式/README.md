# 11 - 装饰器模式 (Decorator Pattern)

> **核心思想**: 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。

## 📚 概念解析

装饰器模式（Decorator Pattern）是一种结构型设计模式，它允许你通过将对象放入包含行为的特殊“包装器”对象中来为原对象绑定新的行为。这种模式在不改变原对象代码的情况下，为其添加新功能，遵循了“开闭原则”。

**主要角色**:
- **组件 (Component)**: 定义了被装饰对象和装饰器的通用接口。
- **具体组件 (Concrete Component)**: 实现了组件接口，是被装饰的原始对象。
- **装饰器 (Decorator)**: 持有一个对组件对象的引用，并实现了与组件相同的接口。
- **具体装饰器 (Concrete Decorator)**: 向组件添加了额外的职责。

## 📂 代码示例

| 文件名                     | 描述                                                           |
| -------------------------- | -------------------------------------------------------------- |
| `01_basic_decorator.py`    | 一个经典的咖啡店示例，演示如何向一杯咖啡中添加牛奶、糖等调料。     |
| `02_function_decorators.py`| 展示了Python中函数装饰器的强大功能，如日志记录、计时、缓存等。   |
| `03_class_decorators.py`   | 演示了如何使用装饰器来修改或增强整个类的行为。                 |
| `04_gui_decorator.py`      | 一个GUI示例，演示如何用装饰器为UI组件添加边框、滚动条等功能。      |
| `05_real_world_examples.py`| 真实世界的应用，如Web框架中的中间件（Middleware）。             |

## ✅ 优点

- **遵循开闭原则**: 可以在不修改现有代码的情况下，为对象添加新功能。
- **比继承更灵活**: 可以在运行时动态地添加或移除功能。
- **可以组合多个装饰器**: 可以将多个装饰器叠加在一个对象上。
- **单一职责**: 每个装饰器只负责一个特定的功能。

## ❌ 缺点

- **可能产生大量小对象**: 使用装饰器模式会产生许多小对象，增加了系统的复杂性。
- **难以移除特定的包装器**: 从包装器栈中移除一个特定的包装器是比较困难的。
- **代码可读性**: 多层装饰器可能会使代码的调用栈变得很长，增加调试难度。

## 🚀 如何运行

```bash
# 运行基础示例
python 11_装饰器模式/01_basic_decorator.py

# 运行函数装饰器示例
python 11_装饰器模式/02_function_decorators.py

# 运行类装饰器示例
python 11_装饰器模式/03_class_decorators.py

# 运行GUI装饰器示例
python 11_装饰器模式/04_gui_decorator.py

# 运行实际应用示例
python 11_装饰器模式/05_real_world_examples.py
```
