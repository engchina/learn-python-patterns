# 命令模式 (Command Pattern)

命令模式是一种行为型设计模式，它将请求封装成对象，从而可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。

## 🎯 模式概述

命令模式的核心思想是将"请求"封装成对象，这样做的好处是：
- **解耦调用者和接收者**：调用者不需要知道具体的执行细节
- **支持撤销和重做**：可以保存命令状态，实现操作的撤销
- **支持队列和日志**：可以将命令排队执行或记录操作历史
- **支持宏命令**：可以组合多个命令形成复合操作

## 📁 文件列表

### 01_basic_command.py
- **目的**: 命令模式的基础实现
- **内容**:
  - 智能家居控制系统
  - 基本的命令封装和执行
  - 简单的撤销机制
- **学习要点**:
  - 命令接口的设计
  - 命令、调用者、接收者的关系
  - 基础的撤销实现

### 02_text_editor.py
- **目的**: 文本编辑器的命令模式实现
- **内容**:
  - 文本编辑操作的命令化
  - 完整的撤销/重做功能
  - 命令历史管理
- **学习要点**:
  - 复杂撤销机制的实现
  - 命令历史栈的管理
  - 状态保存和恢复

### 03_macro_command.py
- **目的**: 宏命令和批量操作
- **内容**:
  - 组合命令的实现
  - 批量操作的封装
  - 复杂业务流程的命令化
- **学习要点**:
  - 组合模式与命令模式的结合
  - 批量操作的撤销
  - 事务性操作的实现

### 04_queue_command.py
- **目的**: 命令队列和异步执行
- **内容**:
  - 命令队列的实现
  - 异步命令执行
  - 任务调度系统
- **学习要点**:
  - 命令的延迟执行
  - 多线程环境下的命令处理
  - 任务优先级和调度

### 05_real_world_examples.py
- **目的**: 实际应用场景示例
- **内容**:
  - 游戏操作记录和回放
  - 数据库事务操作
  - 网络请求重试机制
- **学习要点**:
  - 命令模式在实际项目中的应用
  - 与其他模式的结合使用
  - 性能优化和最佳实践

## 🏗️ 模式结构

```
┌─────────────────┐    调用    ┌─────────────────┐
│     Client      │ ────────→ │    Invoker      │
│   (客户端)       │           │   (调用者)       │
└─────────────────┘           └─────────────────┘
         │                             │
         │ 创建                        │ 持有
         ↓                             ↓
┌─────────────────┐           ┌─────────────────┐
│ ConcreteCommand │           │    Command      │
│   (具体命令)     │ ────────→ │   (抽象命令)     │
└─────────────────┘   实现     └─────────────────┘
         │                             │
         │ 持有                        │ 定义接口
         ↓                             ↓
┌─────────────────┐           ┌─────────────────┐
│    Receiver     │           │  + execute()    │
│   (接收者)       │           │  + undo()       │
└─────────────────┘           └─────────────────┘
```

## 🎭 主要角色

- **Command（抽象命令）**: 定义命令执行的接口，通常包含 execute() 和 undo() 方法
- **ConcreteCommand（具体命令）**: 实现具体的命令操作，持有接收者的引用
- **Receiver（接收者）**: 真正执行业务逻辑的对象，知道如何完成具体操作
- **Invoker（调用者）**: 持有命令对象，负责调用命令的执行方法
- **Client（客户端）**: 创建具体命令对象并配置其接收者

## ✅ 模式优点

1. **降低耦合度**: 调用者与接收者完全解耦，调用者无需知道接收者的具体实现
2. **增强可扩展性**: 可以很容易地增加新的命令类型
3. **支持撤销/重做**: 通过保存命令状态，可以实现操作的撤销和重做
4. **支持日志和审计**: 可以记录所有执行的命令，便于日志记录和审计
5. **支持队列和延迟执行**: 命令可以被存储、排队、延迟执行
6. **支持宏命令**: 可以将多个命令组合成一个复合命令
7. **支持事务**: 可以实现命令的批量提交和回滚

## ❌ 模式缺点

1. **类数量增加**: 每个具体操作都需要创建一个命令类
2. **系统复杂性**: 引入了额外的抽象层，增加了系统的复杂性
3. **内存开销**: 如果需要支持撤销功能，可能需要保存大量的历史状态

## 🎯 适用场景

- **GUI应用程序**: 菜单项、按钮、工具栏的操作封装
- **文本编辑器**: 实现撤销/重做功能
- **游戏开发**: 玩家操作的记录、回放和撤销
- **数据库操作**: 事务的提交和回滚
- **网络请求**: 请求的队列、重试和批处理
- **任务调度**: 定时任务和批量任务的管理
- **API网关**: 请求的路由、限流和监控

## 🚀 快速开始

### 基本使用示例

<augment_code_snippet path="21. Command/01_basic_command.py" mode="EXCERPT">
````python
# 创建智能设备（接收者）
living_room_light = Light("客厅")
bedroom_light = Light("卧室")

# 创建命令对象
living_room_light_on = LightOnCommand(living_room_light, 90)
living_room_light_off = LightOffCommand(living_room_light)

# 创建遥控器（调用者）
remote = SmartRemoteControl()

# 配置遥控器
remote.set_command(0, living_room_light_on, living_room_light_off)

# 执行命令
remote.on_button_pressed(0)  # 开灯
remote.undo_button_pressed()  # 撤销
````
</augment_code_snippet>

### 文本编辑器撤销/重做

<augment_code_snippet path="21. Command/02_text_editor.py" mode="EXCERPT">
````python
# 创建编辑器和控制器
editor = TextEditor()
controller = EditorController(editor)

# 执行编辑操作
insert_cmd = InsertCommand(editor, "Hello World!")
controller.execute_command(insert_cmd)

# 撤销和重做
controller.undo()  # 撤销插入
controller.redo()  # 重做插入
````
</augment_code_snippet>

### 宏命令批量操作

<augment_code_snippet path="21. Command/03_macro_command.py" mode="EXCERPT">
````python
# 批量创建用户
users_data = [
    {'name': '张三', 'email': 'zhangsan@example.com', 'age': 25},
    {'name': '李四', 'email': 'lisi@example.com', 'age': 30}
]

batch_create = BatchUserCreationCommand(db, users_data)
transaction_manager.execute_transaction(batch_create)

# 一键回滚所有操作
transaction_manager.rollback_all_transactions()
````
</augment_code_snippet>

## 🏃‍♂️ 运行示例

```bash
# 基础命令模式
python "01_basic_command.py"

# 文本编辑器撤销/重做
python "02_text_editor.py"

# 宏命令和批量操作
python "03_macro_command.py"

# 命令队列和异步执行
python "04_queue_command.py"

# 实际应用场景
python "05_real_world_examples.py"
```

## 📚 学习路径

### 初级阶段
1. **理解基本概念**: 从 `01_basic_command.py` 开始，理解命令、调用者、接收者的关系
2. **掌握撤销机制**: 学习 `02_text_editor.py` 中的撤销/重做实现
3. **实践基础应用**: 尝试修改智能家居系统，添加新的设备和命令

### 中级阶段
4. **学习宏命令**: 研究 `03_macro_command.py` 中的批量操作和事务处理
5. **掌握异步执行**: 理解 `04_queue_command.py` 中的队列和优先级调度
6. **组合模式应用**: 学会创建复杂的组合命令

### 高级阶段
7. **实际项目应用**: 参考 `05_real_world_examples.py` 中的游戏录制和HTTP重试
8. **性能优化**: 学习命令池、内存管理等优化技巧
9. **模式组合**: 与其他设计模式结合使用

## 🌟 实际应用场景

### GUI应用程序
- **菜单和工具栏**: 将用户操作封装成命令
- **快捷键绑定**: 键盘快捷键与命令的映射
- **撤销/重做系统**: 完整的操作历史管理

### 游戏开发
- **玩家操作记录**: 记录和回放玩家的所有操作
- **技能系统**: 将游戏技能封装成命令
- **AI行为**: 将AI的决策封装成可执行的命令

### 企业应用
- **工作流引擎**: 将业务流程步骤封装成命令
- **批处理系统**: 大量数据处理任务的队列管理
- **API网关**: 请求的路由、限流、重试机制

### 系统集成
- **消息队列**: 异步消息处理和任务调度
- **数据库操作**: 事务的提交、回滚和批量操作
- **微服务通信**: 服务间调用的封装和重试

## 🔗 与其他模式的关系

| 模式 | 关系 | 说明 |
|------|------|------|
| **策略模式** | 相似但不同 | 都封装行为，但命令模式关注请求的封装和延迟执行 |
| **备忘录模式** | 经常组合 | 用于保存命令执行前的状态，支持撤销功能 |
| **组合模式** | 结构组合 | 宏命令使用组合模式来组织子命令 |
| **观察者模式** | 功能互补 | 命令执行时可以通知观察者 |
| **原型模式** | 创建优化 | 用于复制命令对象，避免重复创建 |
| **工厂模式** | 创建管理 | 用于创建不同类型的命令对象 |

## ⚠️ 注意事项和最佳实践

### 内存管理
- **限制历史大小**: 避免无限制地保存命令历史
- **使用弱引用**: 在适当的地方使用弱引用避免内存泄漏
- **及时清理**: 定期清理不再需要的命令对象

### 性能优化
- **命令池**: 对于频繁创建的命令，使用对象池模式
- **批量执行**: 将多个小命令合并成批量操作
- **异步执行**: 对于耗时操作，使用异步命令队列

### 错误处理
- **异常安全**: 确保命令执行失败时的状态一致性
- **回滚机制**: 实现可靠的事务回滚功能
- **日志记录**: 记录命令执行的详细日志

### 设计原则
- **单一职责**: 每个命令只负责一个具体操作
- **接口隔离**: 根据需要定义不同的命令接口
- **依赖倒置**: 依赖抽象的命令接口，而不是具体实现

## 📖 扩展阅读

### 相关设计模式
- **22. Interpreter（解释器模式）**: 命令的解析和执行
- **23. Iterator（迭代器模式）**: 遍历命令集合
- **24. Mediator（中介者模式）**: 命令的协调和管理

### 推荐资源
- 《设计模式：可复用面向对象软件的基础》- GoF
- 《Head First 设计模式》- 命令模式章节
- 《重构：改善既有代码的设计》- 命令模式重构技巧
