# 简单工厂模式 (Simple Factory Pattern)

简单工厂模式是一种创建型设计模式，它提供了一个创建对象的接口，将对象创建逻辑从客户端代码中分离出来，集中到工厂类中。这样可以隐藏对象创建的复杂性，提高代码的可维护性。

## 🎯 模式概述

简单工厂模式的核心思想是"封装对象创建"。它通过一个工厂类来负责创建其他类的实例，客户端不需要知道具体创建哪个类的实例，只需要传递相应的参数给工厂类即可。

### 核心思想
- **封装创建逻辑**: 将复杂的对象创建过程封装在工厂类中
- **统一创建接口**: 提供统一的对象创建入口
- **隐藏实现细节**: 客户端无需了解具体的实现类
- **便于维护**: 创建逻辑的修改只需在工厂类中进行

## 📁 文件列表

### 01_basic_factory.py
- **目的**: 简单工厂模式的基础实现
- **内容**:
  - 图形工厂示例
  - 展示简单工厂的基本结构和使用
- **学习要点**:
  - 简单工厂模式的核心概念
  - 基于参数的对象创建
  - 产品类的层次结构

### 02_calculator_factory.py
- **目的**: 计算器工厂示例
- **内容**:
  - 不同运算类型的计算器创建
  - 运算策略的工厂化管理
- **学习要点**:
  - 实际业务场景中的简单工厂应用
  - 策略模式与简单工厂的结合
  - 运算逻辑的封装

### 03_message_factory.py
- **目的**: 消息处理器工厂示例
- **内容**:
  - 不同类型消息的处理器创建
  - 消息格式化和发送逻辑
- **学习要点**:
  - 消息系统中的工厂模式应用
  - 不同消息类型的统一处理
  - 工厂模式的实际价值

### 04_config_factory.py
- **目的**: 配置管理器工厂示例
- **内容**:
  - 不同格式配置文件的解析器创建
  - 配置加载和管理逻辑
- **学习要点**:
  - 配置系统中的工厂模式应用
  - 文件格式的动态识别
  - 配置解析的统一接口

### 05_real_world_examples.py
- **目的**: 简单工厂模式的实际应用示例
- **内容**:
  - 连接池工厂、验证器工厂等实际场景
  - 展示简单工厂在不同领域的应用
- **学习要点**:
  - 简单工厂的实际应用场景
  - 不同领域的设计技巧
  - 最佳实践和注意事项

## 🏗️ 模式结构

```
┌─────────────────┐    请求创建对象    ┌─────────────────┐
│     客户端      │ ─────────────→ │   简单工厂      │
│    (Client)     │                │  (Factory)      │
└─────────────────┘                └─────────────────┘
                                           │
                                    根据参数创建
                                           │
                                           ▼
                                   ┌─────────────────┐
                                   │   抽象产品      │
                                   │  (Product)      │
                                   └─────────────────┘
                                           △
                                           │ 实现
                                           │
                    ┌──────────────────────┼──────────────────────┐
                    │                      │                      │
                    ▼                      ▼                      ▼
            ┌─────────────┐        ┌─────────────┐        ┌─────────────┐
            │  具体产品A  │        │  具体产品B  │        │  具体产品C  │
            │(ProductA)   │        │(ProductB)   │        │(ProductC)   │
            └─────────────┘        └─────────────┘        └─────────────┘
```

## 👥 主要角色

- **简单工厂 (Factory)**: 负责创建产品对象的工厂类，包含创建逻辑
- **抽象产品 (Product)**: 定义产品对象的公共接口
- **具体产品 (ConcreteProduct)**: 实现抽象产品接口的具体类
- **客户端 (Client)**: 使用工厂创建产品对象的代码

## ✅ 模式优点

1. **封装创建逻辑**: 将复杂的对象创建过程封装在工厂类中
2. **客户端简化**: 客户端无需了解具体的创建细节
3. **集中管理**: 所有创建逻辑集中在一个地方，便于维护
4. **易于测试**: 可以轻松替换工厂实现进行测试
5. **代码复用**: 创建逻辑可以在多个地方复用

## ❌ 模式缺点

1. **违反开闭原则**: 添加新产品需要修改工厂类
2. **工厂类职责过重**: 所有创建逻辑都在一个类中
3. **扩展性有限**: 产品种类增多时工厂类会变得复杂

## 🎯 适用场景

- **对象创建相对简单**: 不需要复杂的创建过程
- **产品种类有限**: 产品类型不会频繁增加
- **创建逻辑集中**: 希望将创建逻辑集中管理
- **客户端简化**: 希望隐藏对象创建的复杂性
- **配置驱动**: 根据配置参数创建不同的对象

## 💡 实现示例

### 基本简单工厂实现

<augment_code_snippet path="5. SimpleFactory/01_basic_factory.py" mode="EXCERPT">
````python
from abc import ABC, abstractmethod

# 抽象产品
class Shape(ABC):
    """图形抽象基类"""

    @abstractmethod
    def draw(self) -> str:
        """绘制图形"""
        pass

    @abstractmethod
    def get_area(self) -> float:
        """计算面积"""
        pass

# 具体产品
class Circle(Shape):
    """圆形"""

    def __init__(self, radius: float):
        self.radius = radius

    def draw(self) -> str:
        return f"绘制圆形，半径: {self.radius}"

    def get_area(self) -> float:
        return 3.14159 * self.radius ** 2

# 简单工厂
class ShapeFactory:
    """图形工厂"""

    @staticmethod
    def create_shape(shape_type: str, **kwargs) -> Shape:
        """创建图形对象"""
        if shape_type.lower() == "circle":
            return Circle(kwargs.get("radius", 1.0))
        elif shape_type.lower() == "rectangle":
            return Rectangle(kwargs.get("width", 1.0), kwargs.get("height", 1.0))
        else:
            raise ValueError(f"不支持的图形类型: {shape_type}")
````
</augment_code_snippet>

## 🚀 运行方法

```bash
# 运行基础简单工厂示例
python 01_basic_factory.py

# 运行计算器工厂示例
python 02_calculator_factory.py

# 运行消息处理器工厂示例
python 03_message_factory.py

# 运行配置管理器工厂示例
python 04_config_factory.py

# 运行实际应用示例
python 05_real_world_examples.py
```

## 📚 学习建议

1. **理解封装**: 深入理解如何封装对象创建逻辑
2. **掌握条件判断**: 学会根据参数选择合适的产品类
3. **多态应用**: 理解多态在简单工厂中的作用
4. **职责分离**: 理解创建逻辑与业务逻辑的分离
5. **实际应用**: 思考在实际项目中的应用场景
6. **对比学习**: 与工厂方法模式进行对比

## 🌍 实际应用场景

- **数据库连接**: 根据配置创建不同类型的数据库连接
- **日志记录**: 根据级别创建不同的日志记录器
- **文件解析**: 根据文件扩展名创建对应的解析器
- **消息处理**: 根据消息类型创建对应的处理器
- **验证器**: 根据验证规则创建对应的验证器

## 🔗 与其他模式的关系

- **工厂方法模式**: 简单工厂的进化版本，更符合开闭原则
- **抽象工厂模式**: 创建相关对象族的模式
- **策略模式**: 都可以根据参数选择不同的实现
- **建造者模式**: 都是创建型模式，但建造者关注复杂对象的构建过程

## ⚠️ 注意事项

1. **避免过度复杂**: 如果产品种类很多，考虑使用工厂方法模式
2. **参数验证**: 确保传入的参数有效，提供清晰的错误信息
3. **性能考虑**: 如果创建过程很重，考虑使用缓存或单例
4. **扩展性**: 考虑未来可能的扩展需求

## 📋 前置知识

- 面向对象编程基础
- 继承和多态的理解
- 抽象类和接口的概念
- Python类定义和使用方法

## 📖 后续学习

- 6. FactoryMethod（工厂方法模式）
- 7. AbstractFactory（抽象工厂模式）
- 9. Builder（建造者模式）

---

*简单工厂模式是学习其他创建型模式的基础，它体现了"封装变化"的设计原则。虽然它有一些局限性，但在合适的场景下仍然是一个非常实用的模式。*
